<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All JS</title>
</head>
<body>
    <div>
        <h1>ALL JS</h1>
        <p>
            Most important in Js
            - expression
            - function
            - Objects


       In js ALMOST everything is object

            Object In JavaScript, 
            an object is an unordered collection of key-value pairs. Order is not important
            Each key-value pair is called a property.

            example: 
            const obj = {
    visible: true,
    colorDepth: 28,
    title: "Test Image",
    orientation: {
        angle: 0,
        type: "landscape"
        }
    }

-Array is an Object.
-Function is an Object.

-Strings and numbers have behavior like object

-console.log() 
-console.dir() all properties of object.
-console.table() all properties of object in table

- console - object,
- log - method or function
- () - call of (function) method log
- console.log('Vazha')   - expression, result of this expression is string 'Vazha'.
        </p>


        <div>
            <h2>Expressions</h2>
            <p>
                All expressions always return value.

               - "Vazha" or 'Vazha'  string (typeof(expression)) // Vazha string
               - 28 number . type of this expression is number // 28 number
              - 5 + 2  expression of number 5, operator "+" and number 2. // 7 number
               Result of this expression will be number 7.
               - с = 10 assignment expression
               - "hello " + "my friend" // hello my friend  string
              - a <= b || c !== d // true or false
              - myFunction(c, d) // result of function
            </p>


            <p>
                expression with side properties:
              -  k = 5  // variable k has been assigned the value 5
              -  b++ // operator '++' increase value of variable b on 1 // b = b + 1
              - function(c, d) take arguments as parameters c, d and then return something
            </p>
        </div>
        <div>
            <h2>Variables</h2>
            <p>
                Variables give ability of repeating access to values
                - Name of variables:
                - PascalCase   for class and type
                - DB_PASSWORD  value of variable is known before running app and will not changed
                - camelCase     all other case.
                Variables should be understandable for all.
                variable declaration:
                var     old shit, can buble up 
                let     we will change the value of this variable, we can only declarate with out 
                        assigning                                                   from ECMAScript 6
                const   value of this variable will not changed, 
                        we must declarete and assign value for this variable     from ECMAScript 6
                let a     declaration of variable a;
                const c = 10    declaration of variable c and assign to it value 10 
                a = true  assign to variable a value true
---------------------------------------------------------------------------------------------------
                console.log(a);  // ReferenceError: a is not defined
                let a
                console.log(a);  // undefined
                let b
                b = true
                console.log(b); // true
            </p>
        </div>
                <div>
                    <h2>Type of variables</h2>
                    <p>
                    Type of variables determined by value of it property.
                    const a = 10; // type of a is number or variable a is number
                    const b = 'abc' // variable b is string
                    </p>
                </div>
                <div>
                    <h2> Types in JS</h2>
                    <p>
                        Primitives:
                        string
                        number
                        bigint
                        boolean
                        undefined
                        symbol
                        null
                        reference (cсылочный) ONLY 1
                       
                        Use reference type we can changed object from different variables
                        <img src="./pictures/reference obj.png" alt="reference type feature">
                        Object :
                        -Array,
                        -Function,
                        -Object
                    </p>
                </div>
                <div>
                    <h2>Object</h2>
                    <p>
                        const objectA = {
                        a: 28,
                        b: false
                        }

                        objectA.c = 'ckocolate'

                        const copyOfA = objectA

                        console.log(copyOfA); // {a: 28, b: false, c: 'ckocolate'} // they are REFERENCE
                    </p>
                </div>
                <div>
                    JS is Dinamic typing language, that's why you can change type of data after 
                    it's declaration.
                    example:
                    let a = 'abcdet' // variable a is string
                    a = 28 // variable a now number ( variable a changed it's type dynamically)
                </div>
                <div>
                    let a = 10;
                    a = true;
                    a = 'vazha'
                    a = undefined
                    function b() {
                    console.log('How are you?');
                    }
                    b() // How are you?
                    b = 4
                    b() // TypeError: b is not a function


                        While you are using Js try declarate const, because you will not have opportunity to
                        change tham.
                        const a = () => {
                        console.log('Good Morning');
                        }
                        a() // Good Morning
-------------------------------------------------------------------------------------------------------------
                        const b = () => {
    console.log('Good Morning');
                        }
                        b = 9
                        b() // TypeError: Assignment to constant variable.
                </div>

                <div>
                    <h2> Object</h2>
                    <p>
                        const myCity = {
                        city: 'Kyiv',
                        popular: true,
                        country: 'Ukraine'
                        }
                        // city is key(property), 'Kyiv" is value of property(key)
                        //getting  values of properties(key)
                        console.log(myCity.city) // 'Kyiv'       // dot notation(dots after words)  
                        console.log(myCity.popular) // true      // dot notation(dots after words)
                        // changing values
                        myCity.city = 'Lviv'
                        console.log(myCity) // {city: 'Lviv', popular: true, country: 'Ukraine'}
                        // adding new properties(key) and values for them
                        myCity.haveMetro = false
                        console.log(myCity) // {city: 'Lviv', popular: true, country: 'Ukraine', haveMetro: false}
                        // deleting properties(key)
                        delete myCity.country
                        console.log(myCity) // {city: 'Lviv', popular: true, haveMetro: false}
                    </p>
                    <p>
                        // Access  to value with []
                    const myCity = {
                    city: 'Kyiv'
                    }
                    myCity['popular'] = true
                    console.log(myCity) // {city: 'Kyiv', popular: true}
                    // Like this also adding.In general we use [''] syntax 
                    when we want give value of special property(key)
                    amd save it in variable.
                    const countryFullName = 'country'  // variable countryFullName assign string 'country'
                    myCity[countryFullName] = 'Ukraine' // obj myCity with key countryFullName assigned  value 'Ukraine'
                    console.log(myCity); // {city: 'Kyiv', popular: true, country: 'Ukraine'}
                    </p>
                   <p>
                    const myCity = {
                    city: 'Kyiv',
                    info: {
                        location: 'good',
                        population: 5000
                        },
                    popular: true, 
                    }
                    // info is nested (вложенный) objec. info is nested value of object - myCity
                    // nesting can be multi-level
                    console.log(myCity.info.population) // 5000
                    delete myCity.info['population'] // deleting nested value with square brackets
                    console.log(myCity);
                   </p>
                        <p>
                    // Using variables as value for object's property

const name = 'Vazha'
const postQty = 28
const userProfile = {
    name: name,              //second name is value of const nam e = 'Vazha'
    postQty: postQty,        //second postQty is value of const postQty 
    magicPower: true
}
// same but more short
// shorthand property
const userProfile2 = {
    name,                   // property and variable must have same name "name"
    postQty,                //  // property and variable must have same name "postQty"
    magicPower: true
}
                        </p>
            <div>
                <h2>GLOBAL OBJECTS</h2>
                <p>
                    window, global, // window in webbrausers , global in node.js
                    globalThis for all
                </p>
            </div>
                </div>

                <div>
                    <h2>Method</h2>
                    <p>
                        Method is property of object.This property has value function.
                        Methods as functions can be called with ()
                        const myCity = {
    city: 'Kyiv',
    cityGreeting: function () {         // cityGreeting is method with value anonymous function
        console.log('Greetings!!');
    }
}

myCity.cityGreeting() // 'Greetings!!'

// shorthand property

const myCity2 = {
    city: 'Kyiv',
    cityGreeting() {  // cityGreeting is method with value anonymous function
        // body of function
        console.log('Greetings to 2!!');
    }
}

myCity2.cityGreeting() // 'Greetings to 2!!' //call of method cityGreeting
                    </p>
                </div>
       <div>
        <h2>JSON</h2>
       <p> JSON - javascript object notation
        JSON is format for changing infromation between computers.
        {
  "name": "All-js",  //key name is string
  "lockfileVersion": 2,
  "requires": true,
  "packages": {}
}

we can use JSON.parse() for json object to convert them into js object 
when we recieve from back end or api

we can use JSON.stringify() to  convert something from js into json

<img src="./pictures/JSON.png" alt="using JSON in console">
       </p> 
       </div> 
       <div>
        <h2>Mutation in JS</h2>
        <p>
            // copy of primitives are coping by values

const a = 10
let b = a
b = 28
console.log(a); // 10
console.log(b); // 28

// copy of objects  are coping of reference, thats why we will mutate the object

const person = {
    name: 'Olga',
    age: 40
}

console.log(person); // {name: 'Olga', age: 40}
person.age = 27
person.isAdult = true
console.log(person); // {name: 'Olga', age: 27, isAdult: true}
console.log(person.isAdult); // true

//Mutation via copies // copy by reference
const person2 = person  // variable person and person 2 have reference to one same object
person2.age = 100
person2.isAdult = false

console.log(person); // {name: 'Olga', age: 100, isAdult: false}


        </p>
        <h2>How avoid mutation during making copy of objects</h2>
        <p>
            // How avoid mutation:

// 1) create new copy with "Object.assign({}, person)" but only if you dont have nested objects inside.
// cause you still have resposibility mutate them in main object
const person = {
    name: 'Olga',
    age: 27
}

const person2 = Object.assign({}, person) // method assign of class and type Object,
                                          // {} new empty object person is base for new obj
person2.age = 200

console.log(person.age); // 27
console.log(person2.age); // 200


// 2) copy with spread operator
// also have problem with nested objects cause the same reason as in first state
const person3 = { ...person };
person3.age = 3
console.log(person3.age);
console.log(person3);
console.log(person);

// 3) copy with JSON methods.Full independent copy
const person4 = JSON.parse(JSON.stringify(person)) // object person convert into string after this it parse(convert into object)
// double convertation
console.log(person4);
        </p>
       </div>        
<div>
    <h2>Function</h2>
    <p>
        The function is a block of code that can be executed multiple times.
        // let a = 5
// let b = 4
// let c;
// c = a + b
// console.log(c); // 9 
// a = 15
// b = 14
// c = a + b
// console.log(c); // 29

// we can optimisate this code

let a = 5;
let b = 9;

function sum(a, b) {  // a and b are parameters of function sum
    const c = a + b
    console.log(c);
}
sum(a, b) // 14     // a and b are arguments during call of function

a = 2;
b = 3;
sum(a, b) // 5      // a and b are arguments during call of function
    </p>
    <p>
        Function can be "A function can be:
        -named
        -anonymous
        -assigned to a variable
        -used as an argument when calling another function (callback)
        -a value of a property (method) of an object.

        Function is object.And as all objects function has also properties.

        function myFunction(a, b) {  // myFunction is name of function, a and b are parameters, {body of function}
    let c                    // parameters of function have behavior as variables
    a = a + 1                // and inside function's body we can make with them some operations
    c = a + b
    return c
}
console.dir(myFunction); // whe can check which properties have function

// If function dont have statement for returning it will return undefined
console.log(myFunction(2, 4)); // 7
const result = myFunction(2, 4)
console.log(result); // 7
        
    </p>
    <h2> Passing(передача) values by reference</h2>
    <p>
    const personVazhiko = {
    name: 'Vazha',
    age: 28
}

function increasePersonAge(person) {  // this function will recieve some obj as argument
    person.age += 1                   // will change its property age
    return person                      // after operation to avoid underfind we are returning obj
}
increasePersonAge(personVazhiko) // personVazhiko and person from function are referenced
                                 //to one object.So function will mutate obj personVazhiko
                                 // copy of obj have not created thats why this function will mutate obj
console.log(personVazhiko.age)   // 29
//It is not recomended to change object inside of function
//Beter is using copy of objects


const personOlga = {
    name: 'Olga',
    age: 27
}

function notMutateIncreasePersonAge(person) {
    const newPerson = { ...person }  // by spread copiing the obj
    newPerson.age += 1  // in copy we change its value
    return newPerson  // we are returning copy with changed property
}
const updatedPerson = notMutateIncreasePersonAge(personOlga) // in variable updated person
                                                //we assign result of calling of function notMutateIncreasePersonAge
                                                //as result we recieve copy of obj with changed value
                                                // of property

console.log(personOlga.age);  // 27 with out mutation (obj personOlga have not changed)
console.log(updatedPerson.age); // 28 updated person it is new obj

    </p>
    <h2>CALLBACK FUNCTION</h2>
    <p>
function someFunction() {
    // Some operations
}
function fnWithCallBack(callbackFn) {   // function fnWithCallBack received 
                                        // as argument antother function
                                        // in body of this funtion, another function
                                        // will called
    
    callbackFn()
}
fnWithCallBack(someFunction)
    </p>
    <p>
        function printMyName() {
    console.log('Vazha');
}

setTimeout(printMyName, 1000) // 'Vazha' // printMyName is callback in function setTimeOut//
                             // setTimeout is special function in JS for window.Like timeout.
                             // first argument is calback function, second arg is 
                             //quantity of delay of miliseconds
    </p>
    <p>
        <h2>RULES FOR WORKING WITH FUNCTIONS</h2>
        <P>
            1) We are giving name to functions basing on what operations they do.The same for variable.
            2) One function make one operation (single purpose function)
            For example if you need sum something and after add some string to this value, it will
            be more readable if it will be 2 functions
            3) It is not recomended to change variables inside the body of function
            So better create copy of something and work with it

        </P>
    </p>
</div>
<div>
    <h2>SCOPE (Область видимости)</h2>
    <p>
        Scope is a mechanism that determines the availability of variables in your code.
        (Область видимости определяет границы действия переменной)
        

        Variables:
        -global (window, console)
        -local inside csope


        let a;                  // global variable declarated
let b;                  // global variable declarated
function myFn() {      //start of local scope
    let b;              // local variable b that is independed(another) from global variable b
   a = false;           // global varibale a assigned by value false
    b = 28;             //local variable b assigned by value 28 because variable b is declarated 
                        // when a = false;
    console.log(b); // 28  // inside scope we are consoling local variable and it's value = 28
}                      // end of local scope

myFn()                  // call of function myFn()

console.log(a);  // false
console.log(b);  // undefined

------------------------------------------------------------------------------------------------------
const a = 5;

function myFn() {
    function innerFn() {
        console.log(a); // 5 we will see after we call functions
    }
    innerFn()
}
myFn()

// if we call innerFn() in global scope we will see error 'innerFn is not defined'

    </p>

    <p>
       Types of Scope:
        -global
        - fuction scope
        -block :for, if else
    </p>
    <h2>RULES FOR WORKING WITH VARIABLES</h2>
    <p>
      1)  All variables should be declarate before using them;
      2) Try always use const if it is possible
      3) Don't change variable from global scope, inside of functions, 

       
    </p>
</div>
<div>
    <h2>'USE STRICT'</h2>
    <p>
        Forbids using undeclared variables.
        'use strict' must be first in global scope or in function scope
    </p>
</div>

<div>
    <h2>OPERATORS</h2>
    <p>
        Operators are special internal functions and they return value as a result.

        Operators:
        -Mathematical operators: 
        Addition + 
        Subtraction - 
        Multiplication * 
        Division /
        Remainder of a division %
        - Comparsion operators: 
        strict equality ===
         strict inequality !== 
          less than or equal   <=
          greater than or equal >=
          - Logic operators:
           NOT ! 
            AND &&
            OR ||
            - Assignment operator =
            -Text operators:
            typeof // type of something
            instanceof // to check belonging to class
            new
            delete

            <p>
let a, b // operator dot is giving ability to declarete 2 or more variables
a = 10
b = a

let c = a + b
console.log(c); // 20
            </p>

    </p>
    <p>
        a = 10 // a and 10 are operands, = is operator
    </p>
    <h2>Unary operators are operators which have one operand(argument) :</h2>
    <p> a++ // operator which increase value of operand on 1
    +a // operator for converting string into number
    delete obj.a // delete operand obj.a 
    typeof a  // operator to get information about type of this operand(a)
    new Obj() // operator which will create obj with class and type</p>
    <h2>Binary operators are operators which have two operand(argument) :</h2>
    <p>
        a = 5
        a + b 
        a += 5 // operator of increasing value 
                //so we increase value on 5 and assign to variable a
        a === b 
        a && b
    </p>
   <p>
    infix notation - operator between operands: a = b
    prefix notation -  operator before operand: ++a, typeof a
    postfix notation - operator after operand : a++


   </p>

   <h2>LOGIC OPERATORS</h2>
   ! // NOT // unary operator and it always return boolean value true or false
   && // AND //    return value of one from operators
   || // OR        return value of one from operators
   <h2>FALSE VALUES</h2>
   <p>
    Boolean(value) => false:
     false // false nothing to add ))
     0 // after convertating into bolean value (call fn Boolen()) it will be false
     '' // after convertating into bolean value (call fn Boolen()) it will be false
     undefined // after convertating into bolean value (call fn Boolen()) it will be false
     null // after convertating into bolean value (call fn Boolen()) it will be false
<img src="./pictures/boolean function.png" alt="">
<img src="./pictures/type of.png" alt="">
   </p>
   <h2>! NOT </h2>
   <p>
    !10 //false
    !0 //true
    !'' //true
    !'Vazaha' //false
    !undefined //true

    double !! not // to get if arg has false value and convert value into boolean value

    const obj = {}
    !!obj //true
    !!undefined //false

   </p>
   <h2>OPERATORS && AND || ARE SHORT CIRCUIT OPERATORS
    ОПЕРАТОРЫ КОРОТКОГО ЗАМЫКАНИЯ
   </h2>
   <h2>Operator &&</h2>
   expression1 && expression2 // each operand is expresssion and returns value
// If expression 1 is falsy:
// 1) expression 2 will be ignored
// 2) return result of expression 1 as reult of expression1 && expression2
// If expression 2 is false while expression 1 is true:
// 1) return result of expression 2 as reult of expression1 && expression2
// if expression 1 and expression 2 true than return last one so expression 2
   
   <p>
    <h2>Operator ||</h2>
    expression1 || expression2 // each operand is expresssion and returns value
// If expression1 is true:
// 1) expression2 will be ignored
// 2) return result of expression1

&& has priority upon || so 
a && b || c && d same like (a && b) || (c && d)
   </p>
</div>
<div>
    <h2>Operator ... </h2> Can be spread or rest
    <p>
        const button = {
    width: 200,
    text: 'Good'
}

const greenButton = {
    ...button,
    color: 'green'
}
// console.dir(greenButton) //  color: "green" // order inside of objject has no difference
                         //    text: "Good"
                         //    width: 200
                         //    [[Prototype]]: Object
//---------------------------------------------------------------------------------------------------
const button1 = {
    width: 200,
    text: 'Good',
    color: 'Brown'
}

const greenButton1 = {
    ...button1,
    color: 'green'
}
// console.dir(greenButton1)  // //  color: "green" // order inside of objject has BIG diference during usage of operator '...'
                            // like this case I have overwritten value of key color, cause destructurisation of object button1
                            // is situated before new object's key color with value 'green'
                         //    text: "Good"
                         //    width: 200
                         //    [[Prototype]]: Object

//---------------------------------------------------------------------------------------------------
const button2 = {
    width: 200,
    text: 'Good',
    color: 'Brown'
}

const greenButton2 = {
    color: 'green',
    ...button2
}
console.dir(greenButton2) // //  color: "brown" // order inside of objject has BIG diference during usage of operator '...'
                            // like this case I have not overwritten value of key color, cause destructurisation of object button1
                            // is situated after new object's key color with value 'green'
                         //    text: "Good"
                         //    width: 200
                         //    [[Prototype]]: Object
    </p>
<h2>// Connecting objects with "spread operator" ...</h2>
<p>
    const buttonInfo = {
text: 'Interest text'
}

const buttonStyle = {
    width: 130,
    height: 40,
    color: 'orange'
}

const allButtonInfo = {
    ...buttonInfo,
    ...buttonStyle
}

console.log(allButtonInfo); //{text: 'Interest text', width: 130, height: 40, color: 'orange'}
                            // If objects which have same key(property), they will be overwritten by the value of the object at the end.
</p>
</div>
<div>
    <h2>String concatenation</h2>
    <h3>Operator + for concatenation</h3>
    <p>
        const banner = "Hello " + "World"
console.log(banner); // Hello World string // backspace after hello can be replaced before world//


const hello = "Hello"
const vazha = "Vazha"
const greeting = hello + " " + vazha
console.log(greeting); // Hello Vazha
    </p>
    <h3>Template string literal(Шаблонные строки)</h3>
    <p>
        const myName = "Vazha"
const myCity = "Kyiv"
console.log(`My name is ${myName}. I live in ${myCity}.`) // very comfortable to use, inside of variables can be everything.//
    </p>
</div>
<div>
    <h2>Functional expression (Функциональные выражения)</h2>
    <h3>Difference between function and functional expression is absence name inside functional expression</h3>
    <p>
        So functional expression is always anonymous.
        // Declarated function
// Declarated function
function myFunction(a, b) {
    let c
    a = a + 28
    c = a + b
    return c
}
// Functional expression
const functionExpression = function(a, b) { // no identefier after word function so it is anonymous// only able inside variable
    let c
    a = a + 28
    c = a + b
    return c
}
console.log(functionExpression(-2, 4)); // 30
//Now fuction expression can be called by name of variable 'const functionExpression'
<img src="./pictures/Function declaration vs Function expression.png" alt="">
    </p>
    <h3>Function expression inside calling of another function(callback)</h3>
    <p>
        setTimeout(function () {
    console.log('Hello');
}, 1000) //function expression console.log('Hello') will called after 1 second 
        // in this case better use functional expression cause we dont need name of this function or we willnot reuse it separately
    </p>
    <h2>Arrow function</h2>
    <p>
        //Arrow function is function expression and it also has not name.
        //Arrow function dont need word fuction only need  "=>" that is why they are "arrow"
const arrowFn = (a, b) => {
    let c;
    a = a + 28
    c = a - b
    return c
}
// console.log(arrowFn(2, 30)) // 0
//---------------------------------------------------------------------------------------------------
//Arrow function with out parameters
let c = 2;
console.log(`Variable "c" before arrowFnWithOutParams = ${c}`); // variable c before arrowFnWithOutParams = 2
const arrowFnWithOutParams = () => {
    c = c + 10
    return c
}
arrowFnWithOutParams()
console.log(`Variable "c" after arrowFnWithOutParams = ${c}`); // variable c after arrowFnWithOutParams = 12
    </p>
    <h3>Main reason why better use function expression  is in variable, that assign with word 'const', 
        so you will not have opportunity to change it, it will give error</h3>
        <h2>Arrow Fn as callback</h2>
        <p>
            setTimeout(() => {
    console.log(`This is arrow function's body`);
}, 2500)
    // String `This is arrow function's body` will shown in console after 2500ms
    //(2500 is delay in 2nd argument of function setTimeout)
        </p>
        <h3>Rules: How make arrow function syntax shorter and more compact</h3>
        <p>
            1) If arrow function have only one parameter, than you dont need using round brackets(круглые скобки) with them
            const arrowFn = a => {
    console.log(`This is body of function expression with one parameter a`);
                a = a + 2
                return a
                            }
        // But still I must use statement return, in other case function will return undefined

            2) If arrow function's body made from one expression  (MOST POPULAR)
            I can write this function with out curly braces(фигурных скобок)
            const arrowFn = ((a, b) => a + b) // In this case after "=>" i dont need to write curly braces(фигурные скобки),
            // cause a + b is only one expression and here is also inserted automaticly return
            // IN ENGLISH CORRECTLY TO SAY THAT IT IS "implicit return"(Неявный возврат).
            
        </p>
</div>
    <h2>Default function parameters</h2>
    <p>
      function multByFactor(value, multipliyer = 1) {  // 2nd parameter multipliyer = 1 by default 
    return value * multipliyer
}
console.log(multByFactor(5, 5)); // 25
// we have overwritten value of multipliyer  = (5), that by default = 1

//But when we call function with default parameter and we have not sent the argument to it's paramter,
//this parameter will take value from default value

console.log(multByFactor(5)); // 5
// we havenot overwritten value of multipliyer,cause we have not given argument to parameter,
//As by default parameter multipliyer = 1.It automatically takes this value as argument
// so for this funtion same result will give
console.log(multByFactor(5, 1)); // 5

// ===============================================================================================
// variant with anonymous function expression
const multByFactor1 = function (value, multipliyer = 1) {
    return value * multipliyer
}
console.log(multByFactor1(5, 5)); // 25
console.log(multByFactor1(5)); // 5

// ===============================================================================================
// variant with arrow function (expression) !MOST POPULAR!
const multByFactor2 = (value, multipliyer = 1) => value * multipliyer
console.log(multByFactor2(5, 5)); // 25
console.log(multByFactor2(5)); // 5

//=========================================================================================================
const newPost = (post, addedAt = Date()) => ({ //function expression assign by variable newPost
                                                //take 1st parametr post which will be object
                                                // addedAt will be always default value as result of global function Date()
                                                // Date() will put there full date in string format whhich will show 
                                                // exact date when function Date() has been called
                                                //'Mon Feb 27 2023 14:55:14 GMT+0200 (Восточная Европа, стандартное время)'
                                                //so we will need put in function expression newPost only one argument object
                                                 //To receive copy of puted object inside of function newPost
                                                 //newPost was made arrow function and it uses "implicit return"(Неявный возврат)                                               
    ...post,                                     // and spread operator with first parametr to make copy from it (copy of object)
    addedAt,     // and put new key "addedAt" with default value = // exact date when function Date() has been called in string format
                // cause our addedAt second parametr have the same name as our new object
})              //so this function take object make from it copy and add one more key addedAt with string of date of calling newPost()
const firstPost = {
    id: 25,
    author: "I"
}

console.log(newPost(firstPost))//{id: 25, author: 'I', addedAt: 'Mon Feb 27 2023 15:21:20 GMT+0200 (Восточная Европа, стандартное время)'}
const result = newPost(firstPost)
console.log(result)// {id: 25, author: 'I', addedAt: 'Mon Feb 27 2023 15:22:35 GMT+0200 (Восточная Европа, стандартное время)'}
//Time shows online(alwasy change acc to when function date called inside function expression newPost)
// Date() not static value

//---------------------------------------------------------------------------------------------------------
//Variant with Explicit return (ЯВНЫЙ ВОЗВРАТ)//
//statement return written inside of arrow function' body
const newPost1 = (post, addedAt = Date()) => {
    const newPost = {
        ...post,
        addedAt
    }
    return newPost
} 
const result1 = newPost1(firstPost)
console.log(result1);// { id: 25, author: 'I', addedAt: 'Mon Feb 27 2023 15:43:16 GMT+0200 (Восточная Европа, стандартное время)' }

    </p>
    <div>
        <h2>"Error handling in JavaScript"(Обработка ошибок)</h2>
        <p>const fnWithError = () => {
    throw new Error("Some error from me")
}
fnWithError() // Uncaught Error: Some error from me // interpritator will not go after this code's string
console.log("Continue..."); // this code will not run cause error</p>
<h2>TRY/CATCH</h2>
<p>
    const fnWithError = () => {
    throw new Error("Some error from me")
}
// fnWithError() // Uncaught Error: Some error from me // interpritator will not go after this code's string
// console.log("Continue..."); // this code will not run cause error

// TRY/CATCH
//try/catch is special syntax which include two blocks of code
try {
     // Here shut be putted part of code where are the potential errors can be.
    //If there is mistake here we will jump to second block catch
} catch (error) {
    // This part of code will executed if block try has error
    // parametr error will give us assec to error and we will have opportunity to check it in console or save on remote server e.t.c
}

try {
    fnWithError() // now this code will execute as it is in try block
                // error of this part of code will sent as argument to block catch
} catch (error) {
    console.error(error); // error catched and look's like Uncaught Error
    console.log(error.message); //"Some error from me"// error is object

}
console.log("Continue...") // code wil executed as usual (with out any errors) cause of try/catch

//It is higly recomended to set part of codes which can broke,inside try/catch blocks, to avoid full script breakage.
</p>
    </div>
    <div>
        <h2>Statement in JS (ИНСТРУКЦИИ)</h2>
        <p>There are: expression(выражение), statement, and expression statement in JS
           <h3> Expression always return value.Can be expression statement</h3>
            <h3>Statement make some operations.Statement can not be transformed into the expression </h3>
            <p>
                example of statements: 
                let a; // statement, variable a only declarated
// each statement better end with " ; " also separate them with empty line
// or at least keep them on different lines
const b = 5;

if (a > b) {                  //this if does not return anything  so this is statement
    console.log("a is bigger"); 
}

for (let i = 0; i < 5; i++) {  
    console.log(i);
}

            </p>
        </p>
        <p>example of expression statements:
            a = a + 3; 

            d = 'Hello ' + 'World';

                myFn(a, c);
        </p>
        difference:
        function myFn(a) {
    console.log(a);
}                       // statement
const b = true;         //expression statement
let c = 10;             //expression statement

myFn(4 + 7) // 11       // expression
myFn(b) // true         // expression
myFn(c = c + 3) // 13  // expression
// myFn(c = c + 3;) // faile try like statement //Uncaught SyntaxError: missing ) after argument list
// myFn(let d) //// faile try like statement// index.js:11 Uncaught SyntaxError: Unexpected strict mode reserved word 
    </div>
    <div>
        <h2>ARRAYS</h2>
     <h3>Array is an object with numeric property names</h3> 
     <p>// HOW CREATE ARRAY
const myArray = [2, 5, 9, 28];
console.log(myArray); // [2, 5, 9, 28] array
const copyOfMyArray = new Array(2, 5, 9, 28)
console.log(copyOfMyArray); // // [2, 5, 9, 28] array
const myArray1 = new Array(2, 5, 9, 28, 1)     //via creation new instance(экземпляр) of a class
console.log(myArray1); // [2, 5, 9, 28, 1] array

// For objects the same
//as array is object but instead of key(property) and value it has index and elements //
//in array order is very important and can be used to find element

console.log(myArray.length); // 4 // .length give "how many elements in array in number"
console.log(myArray1.length); // 5 // 
console.log(myArray === copyOfMyArray); // false //an array is not equal to another array because they occupy different memory cells cause//
//they are objets and reference to different objects and they created in different time
//but if 
const myArray3 = myArray
console.log(myArray3 === myArray); // true // now this links refernced to one object</p>
    </div>
    <div>
        <h2>Array vs Object</h2>
        <p>
            array vissualy similar to object but have different prototype "__proto__" so have different methods to work
            <img src="./pictures/Array vs Obj.png" alt="">

            const myArray = [1, 3, 7, 28]
console.log(myArray);

const myObj = {
    0: 1,
    1: 3,
    2: 7,
    3: 28,
}
console.log(myObj); // don't have lenth
        </p>
        <h3>How get el from array</h3>
        <p>
            const myArray = ['Vazhiko', 28, true]
console.log(myArray[0]); // 'Vazhiko // instead of dots as in object we use square brackets and put index of searching el
console.log(myArray[1]); // 28
console.log(myArray[2]); // true
console.log(myArray.length); // 3 // quantity of elems in array // array length//
myArray.length = 7
console.log(myArray.length); // 7
console.log(myArray); // ['Vazhiko', 28, true, empty × 4]
myArray.length = 3
console.log(myArray); // ['Vazhiko', 28, true]

const myArray = [1, 2, 3, 4]
console.log(myArray); // [1, 2, 3, 4]
console.log(myArray.length); //4

// Change el of array
//index start counting from 0
myArray[2] = 'abcd' // instead of element with index[2], (it is number 3), we assign string 'abcd'
console.log(myArray); // [1, 2, 'abcd', 4]

//Adding elem in array
//as we know length of array so last index will be always value = length - 1 // myArray.length = 4
//last index of myArray = 4 - 1 = 3//
myArray[4] = 'new el of array'
console.log(myArray); // [1, 2, 'abcd', 4, 'new el of array']
console.log(myArray.length); // 5

//In general to work with arrays we will use Array prototype methods or higher-order function (Функции высшего порядка)
        </p>
        <h2>Main methods for working with array</h2>
        <h3>push</h3>
        <h4> Method"push" add element at the end of array</h4>
        <p>
            const myArray = [1, 2, 3, 4] 
myArray.push(5)       // "push" add element at the end of array
console.log(myArray); // [1, 2, 3, 4, 5]
        </p>
        <h3>pop</h3>
        <h4>Method "pop" delete el from the end of array</h4>
        <p>
            const myArray = [1, 2, 3, 4, 5]
myArray.pop()
console.log(myArray); // [1, 2, 3, 4]
const removedEl = myArray.pop() // method POP also can return value which he has deleted
console.log(removedEl); // 4
console.log(myArray); // [1, 2, 3]
        </p>
        <h3>UNSHIFT</h3>
        <h4>Method unshift is adding element at beging of array, all other elements will be reordered automtically</h4>
        <p>
            const myArray = [1, 2, 3]
myArray.unshift("vazha")
console.log(myArray); // ['vazha', 1, 2, 3]
myArray.unshift(true) 
console.log(myArray); // [true, 'vazha', 1, 2, 3]
        </p>
        <h3>SHIFT</h3>
        <h4>Method unshift deletes first element of array after elemnts wil reordered automatically</h4>
        <p>
            const myArray = [1, 2, 3, 4]
myArray.shift()
console.log(myArray);//[2, 3, 4]
const deletedEl = myArray.shift()
console.log(deletedEl); // 2 //also return elem which have been deleted
console.log(myArray); // [3, 4]
        </p>
        <h4>Methods:
            -pop
            -push
            -shift
            -unshift are mutate methods, so they will change array(obj)
        </h4>
        <h2>forEach()POPULAR</h2>
        //forEach is using to iterate over elements make some operations with them
        //it doesnot return anything
const myArray = [1, 2, 3]
console.log(myArray);

myArray.forEach(el => console.log(el * 2)) // method forEach will executed callback function for each element of array (loop цикл)//
// 2, 4, 6
console.log(myArray); // [1, 2, 3] no change
<h2>Map</h2>
<h3>Map also wait as argiment claback function but is returns always array back with same 
length</h3>
<p>
    const myArray = [1, 2, 3]
const newArray = myArray.map(el => el * 5) // [5, 10, 15]
console.log(myArray); // [1, 2, 3]
console.log(newArray); // [5, 10, 15]
//New elemnts of array from map are created as each result of callback function
// for each element of array myArray(on which method map called)
// Original array not changing (myArray)
</p>
    </div>
    <div>
        <h2>Destructuring</h2>
<h3>Destructuring assignment is a special syntax that allows us 
    to “unpack” arrays or objects into a bunch of variables(or one variable), 
    as sometimes that's more convenient(comfortable).
</h3>
<h4>Object destruring</h4>
<p>
const userProfile = {
    name: "Vazha",
    age: 28,
    hasSignedAgreement: true
}

const { hasSignedAgreement } = userProfile // we can recieve all elems or which we need
const { name, age} = userProfile // now we have const variables:
                                        // name, age, hasSignedAgreement with values:
                                        // "Vazha", 28,  true.
                                        //name of variables must be same this is main condition
                                      
console.log(name); //'Vazha'
console.log(age); // 28
console.log(hasSignedAgreement); // true
</p>
<h4>Array destructuring</h4>
<p>
    //As array is also object but with digital property called index
//In array destructuring name of variables inside braces is not important
// but "in which order they are situated" is main condition
//And here we  change curly brackets to square ones

const fruits = ["apple", "lemon", "blueberry"]

const [firstFruit, lemon4ik, sigarette] = fruits
console.log(firstFruit); // "apple"
console.log(lemon4ik); // "lemon"
console.log(sigarette); // "blueberry"
</p>
<h4>Destructuring in function(POPULAR)</h4>
<p>
    const userProfile1 = {
    name: "Vazha",
    folowersQuantity: 33,
    isHeOk: true
}

const userProfile2 = {
    name: "Olga",
    folowersQuantity: 0,
    isSheOk: true
}

//I am intersted only this property of object which will receive my function
const userFolowerInfo = ({ name, folowersQuantity }) => {  // now inside of this fanctions i have asses to key of object
                                                            // if he have same name of key as name of this parameter
    
    if (!folowersQuantity) {                                    // this will check that object's folowersQuantity
                                                                //  have key folowersQuantity and it's value > 0
                                                               
        return `User ${name} has no friends`
    }
    return `User ${name} has ${folowersQuantity} connection in linkEdIn` 
}   

console.log(userFolowerInfo(userProfile1)); // "User Vazha has 33 connection in linkEdIn"
console.log(userFolowerInfo(userProfile2));  // "User Olga has no friends"
</p>
    </div>
    <div>
        <h2>Conditional statements(УСЛОВНЫЕ ИНСТРУКЦИИ)</h2>
        <h3>
            if
            if...else
            switch
            ternary operator (this is expression)
        </h3>
        <h4>if</h4>
        <p>
            // if (condition) {
//     // Block(scope ВНУТРИ ФИГУРНЫХ СКОБООК) of code which will executed only one time
//     // if this condition will return true value
// }
let value = 28;

if (value > 10) {
    value += 20
}

console.log(value); // 48

====================================================================================================================
<h3>POPULAR  "if(!something)</h3>
const person = {
    age: 28
}

if (!person.name) {  // (!undefined === true) // true
    // Other operations if object person has not key(property) name
    // Or value of key(property) name is false
    console.log(`Ты неправильный, у тебя нет имени`); // `Ты неправильный, у тебя нет имени`
    
}
        </p>
        <h4>if...else</h4>
<p>
    // if (condition) {
//     //Block scope of code which will executed ONCE if condtion is true
// } else {
//     // Block scope of code which will executed if condtion is false
// }
// //Executed will only one scope first or second

let value = 28;

if (value < 3) {   //this condition is false
    value += 10  // this part was ignored
} else {
    value -= 40
}

console.log(value); // -12 // 28 - 40 = 12 cause 28 > 3, so if condition is not true
</p>
<h4>if else if</h4>
<p>
    if (condition1) {
     //Block scope of code which will executed ONCE if condtion1 is true
} else if (condition2) {
     //Block scope of code which will executed ONCE if condtion2 is true // as condition1 is false
} else {
    //  Block scope of code which will executed ONCE if previous conditions were false // as condition1 and condition2 are false
  
}
</p>
<h4>more preferable when statement if sepatated empty lines with out else, for example</h4>
<p>
    if (condition1) {
    //Block scope of code which will executed ONCE if condtion1 is true
}

if (condition2) {
    //Block scope of code which will executed ONCE if condtion2 is true
}

if (condition3) {
    //Block scope of code which will executed ONCE if condtion3 is true
}
</p>
<p>
    // const age = 28 // and now we can change  const value and recieve in console.log what we want

// if (age >= 18) {
//     console.log(`Is adult`);
// } else if (age >= 12) {
//     console.log(`Is teenager`);
// } else {
//     console.log(`Is child`);
// }


//=========================================================================================================
// example with only if
//Need include that second condition also first condition to make this statement work correctly

const age = 28

if (age >= 18) {
    console.log(`Is adult`);
}

if (age >= 12 && age < 18) {
    console.log(`Is teenager`);
}

if (age < 12) {
    console.log(`Is child`);
}
</p>
<h3>if in functions POPULAR</h3>
<p>
const sumPositiveNumber = (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') {
        return `One of the arguments is not a number`;
    }

    if (a <= 0 || b <= 0) {
        return `Numbers must be positive`
    }

    return a + b
}

console.log(sumPositiveNumber("Vazha", 50)); // 'One of the arguments is not a number'
console.log(sumPositiveNumber(2, -50)); // 'Numbers must be positive'
console.log(sumPositiveNumber(0, 25)); // 'Numbers must be positive'
console.log(sumPositiveNumber(2, 3)); // 5
</p>
<h3>statement SWITCH() like if...else if</h3>
<p>
    switch (expression) {  
    case A:
        // Operation if expression === A
        break;
    case B:
        // Operation if expression === B
        break;
    case C:
        // Operation if expression === C
        break;
    default:
        // Default operations
}

//===============================================================================================

const month = 2;   

switch (month) {
    case 12:                   // after reserved word 'case', number 12, compare with value of variable 'month' 
        console.log('December');
        break
    case 1:
        console.log('January');
        break
    case 2:
        console.log('February');
        break
    default:
        console.log('This is not winter month');  // al other case
}
</p>
<h3>ternary operator</h3>
<h4>-ternary operator has three operands
    -construction with ternary operator is expression cause iy is returns value
</h4>
<p>
// Condition ? Expression1 : Expression2 // '? and :' are parst of syntax of ternary operator

// "Condition" is also expression
// so if condition return true, this construction,  will return value of Expression1 as finish result
// and if condition return false, this construction,  will return value of Expression2 as finish result

//Inside of ternary operator must be ! expressions ! not statements

//============================================================================================================================
// //example

// // const value = '';  //Value is false
// // const value = 0; //Value is false
// const value = 28; //Value is true
// const value = -10; // Value is true
// value
//     ? console.log('Value is true')
//     : console.log('Value is false')

//================================================================================================================

//example2

// const value1 = 28
// const value2 = 3

// value1 && value2
//     ? myFunction1(value1, value2) //my function will executed if value1 and value2 both true values
//     : myFunction2()

//================================================================================================================

//example3

let value = 10
console.log(value >= 0 ? value : -value) // 11

value = -5
const result = value >= 0 ? value : -value
console.log(result) // 5 //cause second case add '-' and '--' give '+'
//result of ternary operator  we can put in varibale

</p>
    </div>
    <div>
        <h2>Loop(ЦИКЛ)</h2>
        <h3>Loops are a way to repeat the same code multiple times.
            All loops are Statements
        </h3>
        <h3>Loop types:</h3>
        <h4>
            for,
            fore...in,
            while,
            do...while,
            for...of... 
        </h4>
        <h3>for</h3>
        <p>
            //for ( begining statement or initialization(начальная инструкция)
//condition(Условие);
//itteration action(иттерационное действие) or post - expression) {
// statements
//}

// ===========================================================================

// for (initialization; condition; itteration action(operation)) {
//     // statements executed on each itteration
// }
// they all statemnts in general and divided with ';'

//=======================================================================================
//with out loop

let index = 0
console.log(index); // 0
index++
console.log(index); // 1
index++
console.log(index); // 2
index++
console.log(index); // 3
index++
console.log(index); // 4

//=======================================================================================

for (let index = 0; index < 5; index++) { // loop starting with let variable index = 0;
                                          // next step variable index will be compared with number 5
                                          // as index with value 0 less than number five // so condition is executed
                                        // and we get to step itteration action in which we add number 1 to value of variable index
                                        //cause index++ is same like index = index + 1
                                        // loop will working (his body will working) untill condition is true, 
                                        //in our case untill index < 5
                                        // so when index become 5 condition will not executed and 
                                        //we will not recieve access to loop's body
                                        
    console.log(index);     //0
                            //1
                            //2
                            //3
                            //4
}


        </p>
        <p>
        const myArray = ['first', 'second', 'third']

// for (let i = 0; i < myArray.length; i++) {
//     const element = myArray[i];
//     console.log(element); 
   
// }
                            // 'first'
                          // 'second'
                          // 'third'
                          // using square brackets we have recieved i as index of array myArray
                          // with forEach we can get exactly each element of array and if we need to index 
//========================================================================
// with forEach (BEST VARIANT)
myArray.forEach((el, idx) => { //in method forEach I put callback function which will executed for each elem of array
                               // this function recieve two arguments can three but no need here
                                // first is each element of array
                                // second is each index of array
    console.log(el, idx);       // execute this block of code each time as how many elements in array
})

                                // first 0
                                // second 1
                                // third 2

//=============================================================================
        </p>
    </div>
    <h3>loop while need to return cause it can become Infinity</h3>
    <p>
        let i = 0

while (i < 3) {
    console.log(i);
    i++
}

// while i < 3 block of code will be exected
// code in brackets after while can executed, or can not executed,
// then body of this instruction never executed
    </p>
    <h4>do...while</h4>

    <p>
    // do {
//     // Code which will executed on each itteration
// } while (condition);
// // now "body of while" is above, so this body will executed at least one time

let i = 0
do {
    console.log(i);
    i++
} while (i < 5);

//0
//1
//2
//3
//4
    </p>
    <p>
    let i = 10
do {
    console.log(i)
    i++
} while (i < 5) // 10 // statement while is false, block do executed one time,
                      // so i will be shown i console with it's value 10   
    </p>
<h3>for...in</h3>
<p>
    // for (const key in object) {
// // Operations with each obj's key(property)
// // to get key's value  - Object[key]
//     // need use with :
// //     if (Object.hasOwnProperty.call(object, key)) {
// //     const element = object[key];
// // }
//     // othey way this loop iterete not only over object's keys, but also prototype's keys
// }

// const myObj = {
//     x: 'Vazha',
//     y: true,
//     z: 28
// }

// for (const key in myObj) {
//     console.log(key, myObj[key]); // key is each key(property) of obect myObj
//                          // myObj[key] is value of each key(property) of obect myObj
// }
//x Vazha
//y true
//z 28
//=====================================================================================
//forEach for Objects

const myObj = {
    x: 'Vazha',
    y: true,
    z: 28
}

Object.keys(myObj).forEach(key => {
    console.log(key, myObj[key]);
})

//forEach for Objects with only values

Object.values(myObj).forEach(value => {
    console.log(value);
})
<h3>for transforming object into array and work with forEach we can use Object.keys() and Object.values</h3>
<img src="./pictures/Obect.keys.png" alt="">
<img src="./pictures/Object.values().png" alt="">
</p>
<h3>for...of</h3>
const myArray = [1, 4, 5]
// console.dir(array);
// for (const element of Iterable) { // itterable is any substance which is iterable : this mean, that this object can be iterate
//                                     // cause this object or it's prototype chain has key(property) - (Symbol.iterator)
                                  
    
// }

const someArrayEntries = myArray.entries(); //call method entries() return array of key(property), as for key...in loop, 
                                            // but don't get into prototype chain

someArrayEntries.toString();           // "[object Array Iterator]"
console.dir(someArrayEntries);          // Array Iterator
someArrayEntries === someArrayEntries[Symbol.iterator]();    // true // this mean that this substance is iterable

//==========================================================================================================
// for of in string
const myString = 'Vazha'

for (const letter of myString) { // will be 5 itteration according to myString.length
    console.log(letter);
}

//V
//a
//z
//h
//a
<h3>If we have object better conver it into array with Object.keys or Object.values and then work with array using map or for each</h3>


<h2>MODULES</h2>
<h3>Modules give oportunity to avoid dublicating code and destructurisate big js script 
    on many smalls functions which are more usefull.</h3>
    <h4>export/import syntax appeared in ES6</h4>
    <p>
        exported file where function: 
        <img src="./pictures/modules-exported-function.png" alt="">

        file js where exported function will imported
        <img src="./pictures/modules.png" alt="Modules">
        Even you can change name of function because scope is all js file
        example with another names for this function:
        <img src="./pictures/modules with changed function's name.png" alt="">

        Node js can work with modules from v >= 13.
        Modules shut be reusable.
        All exports shut be at the end.
        All imports at the top.
        Better use export default
        See folde modules and pictures
    </p>
    <div>
        <h2>Class and prototype</h2>
        <h3>class is ES 6</h3>
        <h4>We use classes to create "sample" from some obj.
            Classes integred in JS to become object-oriented program langueage </h4>
            <p>
                Class give oportunity to create prototype for different objects.
                Instances(экземпляры ) are created based on prototypes
                Each instance have it's own methods and properties
                Instance can adopt properties or included it's own
                class Comment { //pascal case for class
//body of class 
    constructor(text) {
        this.text = text  // variable "this" indicates on class's instance
                        
        this.votesQty = 0
    }
    upVote() {              // this is performed cause when we will create
        this.votesQty += 1 // new instance will have oportunity to increase it' own
                            // property(key) - votesQty
    }
}
// method constructor called only when I create new instance of exact object

//So during creation of new instance (it will be object)
//which will have two properties(keys) "text:" and "votesQty:"
// with values = text(something that will given
//as argument during executing method constructor) // as default
// and 0 // as default

// To create new instance of class we need reserved word - new.

const firstComment = new Comment('First Comment') // "new Comment('First Comment')"
// call function "constructor(text) with argument as parameter ('First Comment')
console.log(typeof firstComment); // object
console.log(firstComment); // { text: "First Comment", votesQty: 0 }

//this new object will adopt all methods of class
// also this class will prototype for this object(instance of class)
// SEE ON PICTURE
//    <img src="./pictures/instance of class.png" alt=""></img>

//Obj firstComment dont have method "upVote()" but in prototype HAS
//  method "upVote()" is on level class Comment and this method will be
// adopted by all instances of this class
// so we can call this method on obj firstComment.upVote()
firstComment.upVote() // method upVote increase value of property votesQty on 1 (+=1)
console.log(firstComment); // {text: 'First Comment', votesQty: 1}
//So to work with new obj we don't need add method upVote(), cause we already got it
            </p>
            <h2>inheritance through the prototype chain so obj firstComment
                adopt property of class and all property of his prototype "Object"
                Which We can use now 
            </h2>
            <h3>for Example: prototype Object is global in js with his special methods and properties</h3>
   <h3>how to find out if an instance belongs(ПРИНАДЛЕЖИТ) to an object</h3>
   <img src="./pictures/Class creation in console.png" alt="">
   <p>
    class Comment { 
    constructor(text) {
        this.text = text  
        this.votesQty = 0
    }
    upVote() {              
        this.votesQty += 1 
        // property(key) - votesQty
    }
}
const firstComment = new Comment('First Comment') 

// console.log(firstComment instanceof Comment); // true
// console.log(firstComment instanceof Object); // true
// console.log(firstComment); // {text: 'First Comment', votesQty: 0}
// firstComment.upVote()
// console.log(firstComment); // {text: 'First Comment', votesQty: 1}
// firstComment.upVote()
// console.log(firstComment); // { text: 'First Comment', votesQty: 2 }
// // here this reference to exactly this obj if another variable
// //for example "secondComment", "this" will referenced to that obj(instance of class Comment)
   </p>
   <h2>//whose property is this?</h2>
   <h3>Properties (keys) in JavaScript can be either own(СОБСТВЕННЫЕ) or
     inherited(УНАСЛЕДОВАННЫЕ) from the class of this instance.To get information,
    I can use method hasOwnProperty()</h3>
    <p>
        class Comment { 
    constructor(text) {
        this.text = text                // this property will be own to firstComment
        this.votesQty = 0               // this property will be own to firstComment
    }
    upVote() {              
        this.votesQty += 1     // // this property will be in prototype for firstComment
    }
}
const firstComment = new Comment('First Comment') 

console.log(firstComment.hasOwnProperty('text')); // true // property "text" must be in string //
console.log(firstComment.hasOwnProperty('votesQty')); // true
console.log(firstComment.hasOwnProperty('upVote')); // false
console.log(firstComment.hasOwnProperty('hasOwnProperty')); // false // cause hasOwnProperty() is method 
                                                                        //firstComment's prototype "Object"
    </p>
    <h3>creating multiple instances</h3>
    <p>
        class Comment { 
    constructor(text) {
        this.text = text   
        this.votesQty = 0  
    }
    upVote() {              
        this.votesQty += 1     
    }
}
const firstComment = new Comment('First Comment')
const secondComment = new Comment('Second Comment')
const thirdComment = new Comment('Third Olga Comment')


firstComment.upVote()
firstComment.upVote()
firstComment.upVote()
console.log(firstComment); // {text: 'First Comment', votesQty: 3}

secondComment.upVote()
secondComment.upVote()
console.log(secondComment); // {text: 'Second Comment', votesQty: 2}

thirdComment.upVote()
console.log(thirdComment); // {text: 'Third Olga Comment', votesQty: 1}
    </p>
    <h2>STATIC METHODS</h2>
    <h3>Static Method available as property(key) of class and will not inherited by instances</h3>
    <p>
        class Comment { 
    constructor(text) {
        this.text = text   
        this.votesQty = 0  
    }
    upVote() {              
        this.votesQty += 1           // //this method is availabale in all instancesof this class
    }

    static mergeCommencts(first, second) {  //this method is not availabale in instance only on this class
        return `${first}${second}`
    }
}

Comment.mergeCommencts('First Comment', 'Olga`s Comment')

const mySuperComment = new Comment('Super Comment')
console.log(mySuperComment);   // Comment { text: 'Super Comment', votesQty: 0 }
                                // mySuperComment don't have method mergeCommencts at all
    </p>
    <h2>Class extending</h2>
    <p>
    // class NumbersArray extends Array {
//     sum() {
//         return this.reduce((acc, el) => acc += el, 0)
//     }
// }
// const myArray = new NumbersArray(1, 3, 6)
// console.log(myArray);// NumbersArray(3)[1, 3, 6] with prototype Array
// console.log(myArray.sum()); // 10
// <h4>class chain is: myArray => NumbersArray => Array => Object</h4>
// SO EACH Instance( like myArray) of class(NumbersArray) inherites all methods NumbersArray, Array, and Object
========================================================================================================
// найти счастливое число в масивеб то которе повторяется количство раз которое равно ему самому

const myArray = [150, 150, 1, 1, 3, 3, 3, 4, 5, 5, 6, 7, 'abc', 7]
const count = myArray.reduce((acc, el) => {
    acc[el] = (acc[el] || 0) + 1;
    return acc
}, [])

console.log(count);
const luckyValue = count.find((el, idx) => el === idx)
console.log(luckyValue);



//===========================================================


    </p>

    </div>
    <div>
        <h2>What 'PROTOTYPE' is it?</h2>
        <h4>Each class's instance has property(key) which is hidden (__proto__).Thanks to this property we have ability to created
            Prototypal Inheritance.This all give us oportunity to say that JS is Object-Oriented Programming language
        </h4>
    </div>
    <div>
        <h2>
            Promises
        </h2>
        <h3>Promises give oportunity to hanlde events which are deferred(ОТЛОЖЕНЫ) in time</h3>
        <h4>"Promise" is promise return result later in future.Promise can return error if result is not availabale</h4>
        <p>
            Promise can return or resul or error.So promise has 3 conditions: pending, resolve, rejected
        </p>
    </div>
</div>
    <script type="module" src="./index.js"></script>

</body>
</html>